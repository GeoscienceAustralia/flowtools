% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/compute_hec_util.R
\name{compute_crossSection_elev_with_dem}
\alias{compute_crossSection_elev_with_dem}
\title{Update elevation values on a cross-section using a DEM}
\usage{
compute_crossSection_elev_with_dem(section, section_cutline, dem,
  dem_vertical_offset = 0, water_shp = NULL,
  check_watershp = !is.null(water_shp),
  section_alignment_tol = glob_vars$section_alignment_tol,
  compute_new_points = TRUE, desired_spacing = 1, max_section_pts = 400)
}
\arguments{
\item{section}{A 2-column matrix with the 'distance-elevation' points on the
cross-section profile. The first point occurs at the start of section_cutline,
and the last point at the end of section_cutline.}

\item{section_cutline}{A 2-column matrix with the (georeferenced) 'x-y'
points defining the cross-section where the profile is measured. It
does not have the same number of points as 'section', but the start and end points
must coincide, and physically they cover the same transect.}

\item{dem}{A rasterLayer containing the DEM from which we will extract
the new xsection elevations}

\item{dem_vertical_offset}{A number. If provided, this is added to the extracted dem
values before they are returned (to deal with vertical datum offsets)}

\item{water_shp}{A SpatialPolygons/SpatialPolygonsDataFrame where we do NOT update the cross-section
elevation values. A typical use of this would be to exclude areas where the DEM
is known to be inaccurate (e.g. under-water areas for much LIDAR data)}

\item{check_watershp}{TRUE/FALSE Optionally, do not exclude section updates in water_shp, even if it is provided.}

\item{section_alignment_tol}{If the lengths of section_cutline and section[,1] differ by more than this, throw an error}

\item{compute_new_points}{TRUE/FALSE: If true, space the new xsection points
evenly at desired_spacing (or larger if required to not exceed max_section_pts)}

\item{desired_spacing}{The desired (even) spacing of the new xsection points}

\item{max_section_pts}{The maximum number of xsectional points on the output cross-section}
}
\value{
A 2-column matrix with the new distance-elevation points.
}
\description{
Given a cross-section defined by a profile and a spatial 'cutline', replace
the elevations with elevations from a DEM.
Optionally offset the DEM, and do not update points which fall inside a
given polygon shapefile, use the old points/compute new ones, ...
}
\details{
WARNING: Hec-ras does not allow the extreme points on the
             cross-section to be lower than their neighbouring point, and the code will
             ensure that this constraint is met. This can be seen in the example.
}
\examples{
require(raster)
 require(rgdal)
 require(rgeos)

 # Read base data
 mydem=paste0(system.file(package='RgeoRAS'), '/extdata/10m_dem.tif')
 lidar_DEM=raster(mydem)

 # Make an artificial section cutline  (would typically use real data with many more points)
 section_cutline=matrix(c(509619.4, 511972.1, 1610852, 1613042), ncol=2)
 len_section_cutline= sqrt(diff(section_cutline[,1])**2 + diff(section_cutline[,2])**2)
 # Make an artificual section profile along section cutline
 section=matrix(c(seq(0,len_section_cutline,len=4), seq(-20,-20,len=4)),ncol=2)

 # Apply the function
 newsection=compute_crossSection_elev_with_dem(section,section_cutline, lidar_DEM)
 plot(newsection,t='o',pch='.')

 # An example where we keep the points in the original section.
 newsection_test=compute_crossSection_elev_with_dem(section,section_cutline,
                                     lidar_DEM, compute_new_points=FALSE)
 points(newsection_test,t='o',col='red',pch='.')

 # Another example where we keep the section points
 section2=approx(section[,1],section[,2],n=30)
 section2=cbind(section2$x,section2$y)
 newsection2=compute_crossSection_elev_with_dem(section2,section_cutline,
                                       lidar_DEM, compute_new_points=FALSE)
 points(newsection2,t='o',col='blue',pch='.')

 # Suppose there is a region where we don't want to use the DEM
 Exclude_DEM_Poly=SpatialPolygons(list(Polygons(list(Polygon(
                  matrix(c(510414.0, 509977.8, 509977.8, 512158.9, 512740.5, 510414.0,
                            1612569, 1612272, 1612272, 1608996, 1609890, 1612569),ncol=2)
                  )),ID='0')),proj4string=CRS(proj4string(lidar_DEM)))
 newsection_partial=compute_crossSection_elev_with_dem(section,section_cutline,
                                 lidar_DEM, water_shp=Exclude_DEM_Poly)
 points(newsection_partial,t='l',col='orange')

 # Test that it also works for class(water_shp)=SpatialPolygonsDataFrame
 newsection_partial2=compute_crossSection_elev_with_dem(section,section_cutline,
                            lidar_DEM, water_shp=as(Exclude_DEM_Poly,"SpatialPolygonsDataFrame"))
 legend('topleft', c('Fine', 'Very Coarse', 'Medium Coarse', 'Partial exclusion of DEM'),
        lty=rep(1,4),col=c('black','red','blue', 'orange'))
 title(main='Cross-sections with various point densities')
 title(sub='Notice how xsection end points are forced to be higher than their neighbours')
}

